# 테스트 작성 가이드

## 1. 프로젝트 테스트 구조

테스트 코드는 `react-shop-vite-tdd-client/` 디렉토리에 위치하며, 프로젝트의 실제 구조에 따라 다음과 같이 구성됩니다.

```
react-shop-vite-tdd-client/
├── public/              # 정적 파일 (예: 이미지, 아이콘)
│   ├── vite.svg         # Vite 로고
├── src/                 # 소스 코드
│   ├── components/      # UI 컴포넌트
│   ├── pages/           # 페이지 단위 컴포넌트
│   │   ├── CompletePage/
│   │   │   ├── CompletePage.jsx
│   │   ├── OrderPage/
│   │   │   ├── Options.jsx
│   │   │   ├── Products.jsx
│   │   │   ├── OrderPage.jsx
│   │   │   ├── Type.jsx
│   │   │   ├── tests/         # OrderPage 관련 테스트
│   │   │   │   ├── Type.test.jsx
│   │   │   │   ├── calculate.test.jsx
│   │   ├── SummaryPage/
│   │   │   ├── SummaryPage.jsx
│   │   │   ├── tests/         # SummaryPage 관련 테스트
│   │   │   │   ├── SummaryPage.test.jsx
│   ├── hooks/           # 커스텀 훅
│   ├── contexts/        # 전역 상태 관리
│   ├── services/        # API 요청 및 데이터 관리
│   ├── utils/           # 유틸리티 함수
│   │   ├── tests/       # 유틸리티 함수 관련 테스트
│   │   │   ├── processPayment.test.js
│   ├── mocks/           # API Mocking (MSW 핸들러 포함)
│   │   ├── handlers.js
│   │   ├── server.js
│   ├── styles/          # 스타일 및 테마 설정
│   ├── test-utils.jsx   # 테스트 유틸리티 함수
│   ├── setupTests.js    # 테스트 환경 설정 파일
│   ├── App.jsx          # 루트 컴포넌트
│   ├── App.test.jsx     # App 컴포넌트 테스트
│   ├── main.jsx         # 애플리케이션 엔트리 포인트
├── package.json         # 프로젝트 설정 및 의존성
├── package-lock.json    # 패키지 버전 잠금
├── vite.config.js       # Vite 설정 파일
```

- **유닛 테스트**: 개별 컴포넌트, 함수 단위의 테스트 (`*.test.jsx`)

## 2. 테스트 파일 작성 규칙

### 📌 파일 명명 규칙

- 테스트 대상 파일명에 `.test.jsx`를 붙여 작성
- 예시: `App.test.jsx`, `calculate.test.jsx`

### 📌 테스트 설명 (테스트 케이스명)

```jsx
// ❌ 나쁜 예
 test("checkbox and button", () => { ... });

// ✅ 좋은 예
 test("주문 확인 체크박스를 클릭하지 않으면 결제 버튼이 비활성화 상태여야 한다", () => { ... });
```

## 3. 테스트 코드 패턴

### 📌 기본 테스트 구조

```jsx
describe("테스트 그룹명", () => {
  test("테스트 설명", () => {
    // 테스트 코드
    expect(true).toBe(true);
  });
});
```

### 📌 공통적으로 사용되는 헬퍼 함수

```jsx
const findAndTypeInput = async (user, name, value) => {
  const input = await screen.findByRole("spinbutton", { name });
  await user.clear(input);
  await user.type(input, value);
  return input;
};

const findAndClickCheckbox = async (user, name) => {
  const checkbox = await screen.findByRole("checkbox", { name });
  await user.click(checkbox);
  return checkbox;
};
```

## 4. 선택자(Locator) 전략

테스트에서 요소를 찾을 때 접근성 우선 순위를 고려해야 합니다. 아래 기준을 따르는 것이 좋습니다.

### 우선순위
```jsx
// 1. Role과 접근성 속성 (최우선)
await screen.findByRole('button', { name: '로그인' });
await screen.findByLabelText('이메일');
await screen.findByRole('textbox', { name: '비밀번호' });
await screen.findByRole('heading', { name: '회원가입' });

// 2. 텍스트 및 기타
await screen.findByText('계정 만들기');
await screen.findByPlaceholderText('이메일을 입력하세요');

// 3. 테스트 ID (Role과 접근성 속성으로 선택이 어려운 경우에 사용)
// ⚠️ 사용 전 반드시 해당 요소에 data-testid 속성이 정의되어 있는지 확인
await screen.findByTestId('submit-button');

// ❌ 피해야 할 방식 (안티 패턴)
screen.getByClassName('.login-btn');
screen.getBySelector('div > button');
```

## 4. 테스트 작성 예제

### 📌 상품 주문 및 가격 계산 테스트 (`App.test.jsx`, `calculate.test.jsx` 참고)

```jsx
test("상품 개수 변경 시 총 가격이 올바르게 계산된다", async () => {
  const user = userEvent.setup();
  render(<Type orderType="products" />);

  const total = screen.getByText("총 상품 가격:", { exact: false });
  expect(total).toHaveTextContent("0원");

  await findAndTypeInput(user, "America", "2");
  expect(total).toHaveTextContent("2,000원");
});
```

### 📌 옵션 선택 UI 상태 변화 테스트 (`Type.test.jsx` 참고)

```jsx
test("옵션 체크박스 선택 시 총 옵션 가격이 업데이트된다", async () => {
  const user = userEvent.setup();
  render(<Type orderType="options" />);

  const optionsTotal = screen.getByText("총 옵션 가격:", { exact: false });
  expect(optionsTotal).toHaveTextContent("0원");

  await findAndClickCheckbox(user, "Insurance");
  expect(optionsTotal).toHaveTextContent("500원");
});
```

## 5. 검증(Assertions) 가이드

| 유형        | 예제                                                              |
| --------- | --------------------------------------------------------------- |
| 요소 존재 확인  | `expect(screen.getByRole("button")).toBeInTheDocument();`       |
| 텍스트 포함 확인 | `expect(screen.getByText("총 금액")).toHaveTextContent("5,000원");` |
| 요소 활성화 여부 | `expect(screen.getByRole("button")).toBeEnabled();`             |
| 비활성화 확인   | `expect(screen.getByRole("button")).toBeDisabled();`            |

## 6. 테스트 데이터 및 Mocking

### 📌 API Mocking (MSW 활용)
다음과 같은 경우에만 API 모킹을 사용합니다:
- 외부 API 의존성이 있는 경우
- 테스트 환경에서 실제 API가 사용 불가능한 경우
- 특정 에러 상황 테스트가 필요한 경우


```jsx
// 특정 에러 상황 테스트를 위한 모킹 예시
   describe("에러 처리", () => {
        beforeEach(() => {
            // API 요청이 실패하도록 MSW 핸들러 재정의
            server.use(
                http.get("http://localhost:5003/order-history", () => {
                    return new Response(null, { status: 500 });
                })
            );
        });

        test("API 요청 실패 시 에러 메시지가 표시된다", async () => {
            renderWithContext(<CompletePage />);
            
            const errorBanner = await screen.findByTestId("error-banner");
            expect(errorBanner).toBeInTheDocument();
            expect(errorBanner).toHaveTextContent(MESSAGES.ERROR);
        });
    });
```
---

### 📝 **결론**

이 문서는 `@testing-library/react`와 `jest`를 사용한 React 컴포넌트 테스트 가이드입니다. 위의 원칙을 준수하여 일관된 테스트를 작성하면 유지보수가 쉬워지고, 코드 품질이 향상됩니다!
